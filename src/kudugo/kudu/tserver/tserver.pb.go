// Code generated by protoc-gen-go.
// source: kudu/tserver/tserver.proto
// DO NOT EDIT!

/*
Package kudu_tserver is a generated protocol buffer package.

It is generated from these files:
	kudu/tserver/tserver.proto

It has these top-level messages:
	TabletServerErrorPB
	PingRequestPB
	PingResponsePB
	WriteRequestPB
	WriteResponsePB
	ListTabletsRequestPB
	ListTabletsResponsePB
	ColumnRangePredicatePB
	ColumnRangePredicateListPB
	NewScanRequestPB
	ScanRequestPB
	ScanResponsePB
	ScannerKeepAliveRequestPB
	ScannerKeepAliveResponsePB
*/
package kudu_tserver

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import kudu "kudu/common"
import kudu1 "kudu/common"
import kudu_tablet1 "kudu/tablet"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

type TabletServerErrorPB_Code int32

const (
	// An error which has no more specific error code.
	// The code and message in 'status' may reveal more details.
	//
	// RPCs should avoid returning this, since callers will not be
	// able to easily parse the error.
	TabletServerErrorPB_UNKNOWN_ERROR TabletServerErrorPB_Code = 1
	// The schema provided for a request was not well-formed.
	TabletServerErrorPB_INVALID_SCHEMA TabletServerErrorPB_Code = 2
	// The row data provided for a request was not well-formed.
	TabletServerErrorPB_INVALID_ROW_BLOCK TabletServerErrorPB_Code = 3
	// The mutations or mutation keys provided for a request were
	// not well formed.
	TabletServerErrorPB_INVALID_MUTATION TabletServerErrorPB_Code = 4
	// The schema provided for a request didn't match the actual
	// schema of the tablet.
	TabletServerErrorPB_MISMATCHED_SCHEMA TabletServerErrorPB_Code = 5
	// The requested tablet_id is not currently hosted on this server.
	TabletServerErrorPB_TABLET_NOT_FOUND TabletServerErrorPB_Code = 6
	// A request was made against a scanner ID that was either never
	// created or has expired.
	TabletServerErrorPB_SCANNER_EXPIRED TabletServerErrorPB_Code = 7
	// An invalid scan was specified -- e.g the values passed for
	// predicates were incorrect sizes.
	TabletServerErrorPB_INVALID_SCAN_SPEC TabletServerErrorPB_Code = 8
	// The provided configuration was not well-formed and/or
	// had a sequence number that was below the current config.
	TabletServerErrorPB_INVALID_CONFIG TabletServerErrorPB_Code = 9
	// On a create tablet request, signals that the tablet already exists.
	TabletServerErrorPB_TABLET_ALREADY_EXISTS TabletServerErrorPB_Code = 10
	// If the tablet has a newer schema than the requested one the "alter"
	// request will be rejected with this error.
	TabletServerErrorPB_TABLET_HAS_A_NEWER_SCHEMA TabletServerErrorPB_Code = 11
	// The tablet is hosted on this server, but not in RUNNING state.
	TabletServerErrorPB_TABLET_NOT_RUNNING TabletServerErrorPB_Code = 12
	// Client requested a snapshot read but the snapshot was invalid.
	TabletServerErrorPB_INVALID_SNAPSHOT TabletServerErrorPB_Code = 13
	// An invalid scan call sequence ID was specified.
	TabletServerErrorPB_INVALID_SCAN_CALL_SEQ_ID TabletServerErrorPB_Code = 14
	// This tserver is not the leader of the consensus configuration.
	TabletServerErrorPB_NOT_THE_LEADER TabletServerErrorPB_Code = 15
	// The destination UUID in the request does not match this server.
	TabletServerErrorPB_WRONG_SERVER_UUID TabletServerErrorPB_Code = 16
	// The compare-and-swap specified by an atomic RPC operation failed.
	TabletServerErrorPB_CAS_FAILED TabletServerErrorPB_Code = 17
	// The requested operation is already inprogress, e.g. RemoteBootstrap.
	TabletServerErrorPB_ALREADY_INPROGRESS TabletServerErrorPB_Code = 18
)

var TabletServerErrorPB_Code_name = map[int32]string{
	1:  "UNKNOWN_ERROR",
	2:  "INVALID_SCHEMA",
	3:  "INVALID_ROW_BLOCK",
	4:  "INVALID_MUTATION",
	5:  "MISMATCHED_SCHEMA",
	6:  "TABLET_NOT_FOUND",
	7:  "SCANNER_EXPIRED",
	8:  "INVALID_SCAN_SPEC",
	9:  "INVALID_CONFIG",
	10: "TABLET_ALREADY_EXISTS",
	11: "TABLET_HAS_A_NEWER_SCHEMA",
	12: "TABLET_NOT_RUNNING",
	13: "INVALID_SNAPSHOT",
	14: "INVALID_SCAN_CALL_SEQ_ID",
	15: "NOT_THE_LEADER",
	16: "WRONG_SERVER_UUID",
	17: "CAS_FAILED",
	18: "ALREADY_INPROGRESS",
}
var TabletServerErrorPB_Code_value = map[string]int32{
	"UNKNOWN_ERROR":             1,
	"INVALID_SCHEMA":            2,
	"INVALID_ROW_BLOCK":         3,
	"INVALID_MUTATION":          4,
	"MISMATCHED_SCHEMA":         5,
	"TABLET_NOT_FOUND":          6,
	"SCANNER_EXPIRED":           7,
	"INVALID_SCAN_SPEC":         8,
	"INVALID_CONFIG":            9,
	"TABLET_ALREADY_EXISTS":     10,
	"TABLET_HAS_A_NEWER_SCHEMA": 11,
	"TABLET_NOT_RUNNING":        12,
	"INVALID_SNAPSHOT":          13,
	"INVALID_SCAN_CALL_SEQ_ID":  14,
	"NOT_THE_LEADER":            15,
	"WRONG_SERVER_UUID":         16,
	"CAS_FAILED":                17,
	"ALREADY_INPROGRESS":        18,
}

func (x TabletServerErrorPB_Code) Enum() *TabletServerErrorPB_Code {
	p := new(TabletServerErrorPB_Code)
	*p = x
	return p
}
func (x TabletServerErrorPB_Code) String() string {
	return proto.EnumName(TabletServerErrorPB_Code_name, int32(x))
}
func (x *TabletServerErrorPB_Code) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TabletServerErrorPB_Code_value, data, "TabletServerErrorPB_Code")
	if err != nil {
		return err
	}
	*x = TabletServerErrorPB_Code(value)
	return nil
}
func (TabletServerErrorPB_Code) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

// Tablet-server specific errors use this protobuf.
type TabletServerErrorPB struct {
	// The error code.
	Code *TabletServerErrorPB_Code `protobuf:"varint,1,req,name=code,enum=kudu.tserver.TabletServerErrorPB_Code,def=1" json:"code,omitempty"`
	// The Status object for the error. This will include a textual
	// message that may be more useful to present in log messages, etc,
	// though its error code is less specific.
	Status           *kudu1.AppStatusPB `protobuf:"bytes,2,req,name=status" json:"status,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *TabletServerErrorPB) Reset()                    { *m = TabletServerErrorPB{} }
func (m *TabletServerErrorPB) String() string            { return proto.CompactTextString(m) }
func (*TabletServerErrorPB) ProtoMessage()               {}
func (*TabletServerErrorPB) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

const Default_TabletServerErrorPB_Code TabletServerErrorPB_Code = TabletServerErrorPB_UNKNOWN_ERROR

func (m *TabletServerErrorPB) GetCode() TabletServerErrorPB_Code {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return Default_TabletServerErrorPB_Code
}

func (m *TabletServerErrorPB) GetStatus() *kudu1.AppStatusPB {
	if m != nil {
		return m.Status
	}
	return nil
}

type PingRequestPB struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *PingRequestPB) Reset()                    { *m = PingRequestPB{} }
func (m *PingRequestPB) String() string            { return proto.CompactTextString(m) }
func (*PingRequestPB) ProtoMessage()               {}
func (*PingRequestPB) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type PingResponsePB struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *PingResponsePB) Reset()                    { *m = PingResponsePB{} }
func (m *PingResponsePB) String() string            { return proto.CompactTextString(m) }
func (*PingResponsePB) ProtoMessage()               {}
func (*PingResponsePB) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// A batched set of insert/mutate requests.
type WriteRequestPB struct {
	TabletId []byte `protobuf:"bytes,1,req,name=tablet_id,json=tabletId" json:"tablet_id,omitempty"`
	// The schema as seen by the client. This may be out-of-date, in which case
	// it will be projected to the current schema automatically, with defaults/NULLs
	// being filled in.
	Schema *kudu.SchemaPB `protobuf:"bytes,2,opt,name=schema" json:"schema,omitempty"`
	// Operations to perform (insert/update/delete)
	RowOperations *kudu1.RowOperationsPB `protobuf:"bytes,3,opt,name=row_operations,json=rowOperations" json:"row_operations,omitempty"`
	// The required consistency mode for this write.
	ExternalConsistencyMode *kudu.ExternalConsistencyMode `protobuf:"varint,4,opt,name=external_consistency_mode,json=externalConsistencyMode,enum=kudu.ExternalConsistencyMode,def=1" json:"external_consistency_mode,omitempty"`
	// A timestamp obtained by the client from a previous request.
	// TODO crypto sign this and propagate the signature along with
	// the timestamp.
	PropagatedTimestamp *uint64 `protobuf:"fixed64,5,opt,name=propagated_timestamp,json=propagatedTimestamp" json:"propagated_timestamp,omitempty"`
	XXX_unrecognized    []byte  `json:"-"`
}

func (m *WriteRequestPB) Reset()                    { *m = WriteRequestPB{} }
func (m *WriteRequestPB) String() string            { return proto.CompactTextString(m) }
func (*WriteRequestPB) ProtoMessage()               {}
func (*WriteRequestPB) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

const Default_WriteRequestPB_ExternalConsistencyMode kudu.ExternalConsistencyMode = kudu.ExternalConsistencyMode_CLIENT_PROPAGATED

func (m *WriteRequestPB) GetTabletId() []byte {
	if m != nil {
		return m.TabletId
	}
	return nil
}

func (m *WriteRequestPB) GetSchema() *kudu.SchemaPB {
	if m != nil {
		return m.Schema
	}
	return nil
}

func (m *WriteRequestPB) GetRowOperations() *kudu1.RowOperationsPB {
	if m != nil {
		return m.RowOperations
	}
	return nil
}

func (m *WriteRequestPB) GetExternalConsistencyMode() kudu.ExternalConsistencyMode {
	if m != nil && m.ExternalConsistencyMode != nil {
		return *m.ExternalConsistencyMode
	}
	return Default_WriteRequestPB_ExternalConsistencyMode
}

func (m *WriteRequestPB) GetPropagatedTimestamp() uint64 {
	if m != nil && m.PropagatedTimestamp != nil {
		return *m.PropagatedTimestamp
	}
	return 0
}

type WriteResponsePB struct {
	// If the entire WriteResponsePB request failed, the error status that
	// caused the failure. This type of error is triggered for
	// cases such as the tablet not being on this server, or the
	// schema not matching. If any error specific to a given row
	// occurs, this error will be recorded in per_row_errors below,
	// even if all rows failed.
	Error        *TabletServerErrorPB             `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	PerRowErrors []*WriteResponsePB_PerRowErrorPB `protobuf:"bytes,2,rep,name=per_row_errors,json=perRowErrors" json:"per_row_errors,omitempty"`
	// The timestamp chosen by the server for this write.
	// TODO KUDU-611 propagate timestamps with server signature.
	Timestamp        *uint64 `protobuf:"fixed64,3,opt,name=timestamp" json:"timestamp,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *WriteResponsePB) Reset()                    { *m = WriteResponsePB{} }
func (m *WriteResponsePB) String() string            { return proto.CompactTextString(m) }
func (*WriteResponsePB) ProtoMessage()               {}
func (*WriteResponsePB) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *WriteResponsePB) GetError() *TabletServerErrorPB {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *WriteResponsePB) GetPerRowErrors() []*WriteResponsePB_PerRowErrorPB {
	if m != nil {
		return m.PerRowErrors
	}
	return nil
}

func (m *WriteResponsePB) GetTimestamp() uint64 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

// If errors occurred with particular row operations, then the errors
// for those operations will be passed back in 'per_row_errors'.
type WriteResponsePB_PerRowErrorPB struct {
	// The index of the row in the incoming batch.
	RowIndex *int32 `protobuf:"varint,1,req,name=row_index,json=rowIndex" json:"row_index,omitempty"`
	// The error that occurred.
	Error            *kudu1.AppStatusPB `protobuf:"bytes,2,req,name=error" json:"error,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *WriteResponsePB_PerRowErrorPB) Reset()         { *m = WriteResponsePB_PerRowErrorPB{} }
func (m *WriteResponsePB_PerRowErrorPB) String() string { return proto.CompactTextString(m) }
func (*WriteResponsePB_PerRowErrorPB) ProtoMessage()    {}
func (*WriteResponsePB_PerRowErrorPB) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 0}
}

func (m *WriteResponsePB_PerRowErrorPB) GetRowIndex() int32 {
	if m != nil && m.RowIndex != nil {
		return *m.RowIndex
	}
	return 0
}

func (m *WriteResponsePB_PerRowErrorPB) GetError() *kudu1.AppStatusPB {
	if m != nil {
		return m.Error
	}
	return nil
}

// A list tablets request
type ListTabletsRequestPB struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *ListTabletsRequestPB) Reset()                    { *m = ListTabletsRequestPB{} }
func (m *ListTabletsRequestPB) String() string            { return proto.CompactTextString(m) }
func (*ListTabletsRequestPB) ProtoMessage()               {}
func (*ListTabletsRequestPB) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

// A list tablets response
type ListTabletsResponsePB struct {
	Error            *TabletServerErrorPB                       `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	StatusAndSchema  []*ListTabletsResponsePB_StatusAndSchemaPB `protobuf:"bytes,2,rep,name=status_and_schema,json=statusAndSchema" json:"status_and_schema,omitempty"`
	XXX_unrecognized []byte                                     `json:"-"`
}

func (m *ListTabletsResponsePB) Reset()                    { *m = ListTabletsResponsePB{} }
func (m *ListTabletsResponsePB) String() string            { return proto.CompactTextString(m) }
func (*ListTabletsResponsePB) ProtoMessage()               {}
func (*ListTabletsResponsePB) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ListTabletsResponsePB) GetError() *TabletServerErrorPB {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ListTabletsResponsePB) GetStatusAndSchema() []*ListTabletsResponsePB_StatusAndSchemaPB {
	if m != nil {
		return m.StatusAndSchema
	}
	return nil
}

type ListTabletsResponsePB_StatusAndSchemaPB struct {
	TabletStatus     *kudu_tablet1.TabletStatusPB `protobuf:"bytes,1,req,name=tablet_status,json=tabletStatus" json:"tablet_status,omitempty"`
	Schema           *kudu.SchemaPB               `protobuf:"bytes,2,req,name=schema" json:"schema,omitempty"`
	PartitionSchema  *kudu.PartitionSchemaPB      `protobuf:"bytes,3,opt,name=partition_schema,json=partitionSchema" json:"partition_schema,omitempty"`
	XXX_unrecognized []byte                       `json:"-"`
}

func (m *ListTabletsResponsePB_StatusAndSchemaPB) Reset() {
	*m = ListTabletsResponsePB_StatusAndSchemaPB{}
}
func (m *ListTabletsResponsePB_StatusAndSchemaPB) String() string { return proto.CompactTextString(m) }
func (*ListTabletsResponsePB_StatusAndSchemaPB) ProtoMessage()    {}
func (*ListTabletsResponsePB_StatusAndSchemaPB) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{6, 0}
}

func (m *ListTabletsResponsePB_StatusAndSchemaPB) GetTabletStatus() *kudu_tablet1.TabletStatusPB {
	if m != nil {
		return m.TabletStatus
	}
	return nil
}

func (m *ListTabletsResponsePB_StatusAndSchemaPB) GetSchema() *kudu.SchemaPB {
	if m != nil {
		return m.Schema
	}
	return nil
}

func (m *ListTabletsResponsePB_StatusAndSchemaPB) GetPartitionSchema() *kudu.PartitionSchemaPB {
	if m != nil {
		return m.PartitionSchema
	}
	return nil
}

// A range predicate on one of the columns in the underlying
// data.
type ColumnRangePredicatePB struct {
	Column *kudu.ColumnSchemaPB `protobuf:"bytes,1,req,name=column" json:"column,omitempty"`
	// These bounds should be encoded as follows:
	// - STRING values: simply the exact string value for the bound.
	// - other type: the canonical x86 in-memory representation -- eg for
	//   uint32s, a little-endian value.
	//
	// Note that this predicate type should not be used for NULL data --
	// NULL is defined to neither be greater than or less than other values
	// for the comparison operator. We will eventually add a special
	// predicate type for null-ness.
	LowerBound       []byte `protobuf:"bytes,2,opt,name=lower_bound,json=lowerBound" json:"lower_bound,omitempty"`
	UpperBound       []byte `protobuf:"bytes,3,opt,name=upper_bound,json=upperBound" json:"upper_bound,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ColumnRangePredicatePB) Reset()                    { *m = ColumnRangePredicatePB{} }
func (m *ColumnRangePredicatePB) String() string            { return proto.CompactTextString(m) }
func (*ColumnRangePredicatePB) ProtoMessage()               {}
func (*ColumnRangePredicatePB) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *ColumnRangePredicatePB) GetColumn() *kudu.ColumnSchemaPB {
	if m != nil {
		return m.Column
	}
	return nil
}

func (m *ColumnRangePredicatePB) GetLowerBound() []byte {
	if m != nil {
		return m.LowerBound
	}
	return nil
}

func (m *ColumnRangePredicatePB) GetUpperBound() []byte {
	if m != nil {
		return m.UpperBound
	}
	return nil
}

// List of predicates used by the Java client. Will rapidly evolve into something more reusable
// as a way to pass scanner configurations.
type ColumnRangePredicateListPB struct {
	RangePredicates  []*ColumnRangePredicatePB `protobuf:"bytes,1,rep,name=range_predicates,json=rangePredicates" json:"range_predicates,omitempty"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *ColumnRangePredicateListPB) Reset()                    { *m = ColumnRangePredicateListPB{} }
func (m *ColumnRangePredicateListPB) String() string            { return proto.CompactTextString(m) }
func (*ColumnRangePredicateListPB) ProtoMessage()               {}
func (*ColumnRangePredicateListPB) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ColumnRangePredicateListPB) GetRangePredicates() []*ColumnRangePredicatePB {
	if m != nil {
		return m.RangePredicates
	}
	return nil
}

type NewScanRequestPB struct {
	// The tablet to scan.
	TabletId []byte `protobuf:"bytes,1,req,name=tablet_id,json=tabletId" json:"tablet_id,omitempty"`
	// The maximum number of rows to scan.
	// The scanner will automatically stop yielding results and close
	// itself after reaching this number of result rows.
	Limit *uint64 `protobuf:"varint,2,opt,name=limit" json:"limit,omitempty"`
	// Any column range predicates to enforce.
	RangePredicates []*ColumnRangePredicatePB `protobuf:"bytes,3,rep,name=range_predicates,json=rangePredicates" json:"range_predicates,omitempty"`
	// Encoded primary key to begin scanning at (inclusive).
	StartPrimaryKey []byte `protobuf:"bytes,8,opt,name=start_primary_key,json=startPrimaryKey" json:"start_primary_key,omitempty"`
	// Encoded primary key to stop scanning at (exclusive).
	StopPrimaryKey []byte `protobuf:"bytes,9,opt,name=stop_primary_key,json=stopPrimaryKey" json:"stop_primary_key,omitempty"`
	// Which columns to select.
	// if this is an empty list, no data will be returned, but the num_rows
	// field of the returned RowBlock will indicate how many rows passed
	// the predicates. Note that in some cases, the scan may still require
	// multiple round-trips, and the caller must aggregate the counts.
	ProjectedColumns []*kudu.ColumnSchemaPB `protobuf:"bytes,4,rep,name=projected_columns,json=projectedColumns" json:"projected_columns,omitempty"`
	// The read mode for this scan request.
	// See common.proto for further information about read modes.
	ReadMode *kudu.ReadMode `protobuf:"varint,5,opt,name=read_mode,json=readMode,enum=kudu.ReadMode,def=1" json:"read_mode,omitempty"`
	// The requested snapshot timestamp. This is only used
	// when the read mode is set to READ_AT_SNAPSHOT.
	SnapTimestamp *uint64 `protobuf:"fixed64,6,opt,name=snap_timestamp,json=snapTimestamp" json:"snap_timestamp,omitempty"`
	// Sent by clients which previously executed CLIENT_PROPAGATED writes.
	// This updates the server's time so that no transaction will be assigned
	// a timestamp lower than or equal to 'previous_known_timestamp'
	PropagatedTimestamp *uint64 `protobuf:"fixed64,7,opt,name=propagated_timestamp,json=propagatedTimestamp" json:"propagated_timestamp,omitempty"`
	// Whether data blocks will be cached when read from the files or discarded after use.
	// Disable this to lower cache churn when doing large scans.
	CacheBlocks *bool `protobuf:"varint,10,opt,name=cache_blocks,json=cacheBlocks,def=1" json:"cache_blocks,omitempty"`
	// Whether to order the returned rows by primary key.
	// This is used for scanner fault-tolerance.
	OrderMode *kudu.OrderMode `protobuf:"varint,11,opt,name=order_mode,json=orderMode,enum=kudu.OrderMode,def=1" json:"order_mode,omitempty"`
	// If retrying a scan, the final primary key retrieved in the previous scan
	// attempt. If set, this will take precedence over the `start_primary_key`
	// field, and functions as an exclusive start primary key.
	LastPrimaryKey   []byte `protobuf:"bytes,12,opt,name=last_primary_key,json=lastPrimaryKey" json:"last_primary_key,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *NewScanRequestPB) Reset()                    { *m = NewScanRequestPB{} }
func (m *NewScanRequestPB) String() string            { return proto.CompactTextString(m) }
func (*NewScanRequestPB) ProtoMessage()               {}
func (*NewScanRequestPB) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

const Default_NewScanRequestPB_ReadMode kudu.ReadMode = kudu.ReadMode_READ_LATEST
const Default_NewScanRequestPB_CacheBlocks bool = true
const Default_NewScanRequestPB_OrderMode kudu.OrderMode = kudu.OrderMode_UNORDERED

func (m *NewScanRequestPB) GetTabletId() []byte {
	if m != nil {
		return m.TabletId
	}
	return nil
}

func (m *NewScanRequestPB) GetLimit() uint64 {
	if m != nil && m.Limit != nil {
		return *m.Limit
	}
	return 0
}

func (m *NewScanRequestPB) GetRangePredicates() []*ColumnRangePredicatePB {
	if m != nil {
		return m.RangePredicates
	}
	return nil
}

func (m *NewScanRequestPB) GetStartPrimaryKey() []byte {
	if m != nil {
		return m.StartPrimaryKey
	}
	return nil
}

func (m *NewScanRequestPB) GetStopPrimaryKey() []byte {
	if m != nil {
		return m.StopPrimaryKey
	}
	return nil
}

func (m *NewScanRequestPB) GetProjectedColumns() []*kudu.ColumnSchemaPB {
	if m != nil {
		return m.ProjectedColumns
	}
	return nil
}

func (m *NewScanRequestPB) GetReadMode() kudu.ReadMode {
	if m != nil && m.ReadMode != nil {
		return *m.ReadMode
	}
	return Default_NewScanRequestPB_ReadMode
}

func (m *NewScanRequestPB) GetSnapTimestamp() uint64 {
	if m != nil && m.SnapTimestamp != nil {
		return *m.SnapTimestamp
	}
	return 0
}

func (m *NewScanRequestPB) GetPropagatedTimestamp() uint64 {
	if m != nil && m.PropagatedTimestamp != nil {
		return *m.PropagatedTimestamp
	}
	return 0
}

func (m *NewScanRequestPB) GetCacheBlocks() bool {
	if m != nil && m.CacheBlocks != nil {
		return *m.CacheBlocks
	}
	return Default_NewScanRequestPB_CacheBlocks
}

func (m *NewScanRequestPB) GetOrderMode() kudu.OrderMode {
	if m != nil && m.OrderMode != nil {
		return *m.OrderMode
	}
	return Default_NewScanRequestPB_OrderMode
}

func (m *NewScanRequestPB) GetLastPrimaryKey() []byte {
	if m != nil {
		return m.LastPrimaryKey
	}
	return nil
}

// A scan request. Initially, it should specify a scan. Later on, you
// can use the scanner id returned to fetch result batches with a different
// scan request.
//
// The scanner will remain open if there are more results, and it's not
// asked to be closed explicitly. Some errors on the Tablet Server may
// close the scanner automatically if the scanner state becomes
// inconsistent.
//
// Clients may choose to retry scan requests that fail to complete (due to, for
// example, a timeout or network error). If a scan request completes with an
// error result, the scanner should be closed by the client.
//
// You can fetch the results and ask the scanner to be closed to save
// a trip if you are not interested in remaining results.
//
// This is modeled somewhat after HBase's scanner API.
type ScanRequestPB struct {
	// If continuing an existing scan, then you must set scanner_id.
	// Otherwise, you must set 'new_scan_request'.
	ScannerId      []byte            `protobuf:"bytes,1,opt,name=scanner_id,json=scannerId" json:"scanner_id,omitempty"`
	NewScanRequest *NewScanRequestPB `protobuf:"bytes,2,opt,name=new_scan_request,json=newScanRequest" json:"new_scan_request,omitempty"`
	// The sequence ID of this call. The sequence ID should start at 0
	// with the request for a new scanner, and after each successful request,
	// the client should increment it by 1. When retrying a request, the client
	// should _not_ increment this value. If the server detects that the client
	// missed a chunk of rows from the middle of a scan, it will respond with an
	// error.
	CallSeqId *uint32 `protobuf:"varint,3,opt,name=call_seq_id,json=callSeqId" json:"call_seq_id,omitempty"`
	// The maximum number of bytes to send in the response.
	// This is a hint, not a requirement: the server may send
	// arbitrarily fewer or more bytes than requested.
	BatchSizeBytes *uint32 `protobuf:"varint,4,opt,name=batch_size_bytes,json=batchSizeBytes" json:"batch_size_bytes,omitempty"`
	// If set, the server will close the scanner after responding to
	// this request, regardless of whether all rows have been delivered.
	// In order to simply close a scanner without selecting any rows, you
	// may set batch_size_bytes to 0 in conjunction with setting this flag.
	CloseScanner     *bool  `protobuf:"varint,5,opt,name=close_scanner,json=closeScanner" json:"close_scanner,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ScanRequestPB) Reset()                    { *m = ScanRequestPB{} }
func (m *ScanRequestPB) String() string            { return proto.CompactTextString(m) }
func (*ScanRequestPB) ProtoMessage()               {}
func (*ScanRequestPB) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ScanRequestPB) GetScannerId() []byte {
	if m != nil {
		return m.ScannerId
	}
	return nil
}

func (m *ScanRequestPB) GetNewScanRequest() *NewScanRequestPB {
	if m != nil {
		return m.NewScanRequest
	}
	return nil
}

func (m *ScanRequestPB) GetCallSeqId() uint32 {
	if m != nil && m.CallSeqId != nil {
		return *m.CallSeqId
	}
	return 0
}

func (m *ScanRequestPB) GetBatchSizeBytes() uint32 {
	if m != nil && m.BatchSizeBytes != nil {
		return *m.BatchSizeBytes
	}
	return 0
}

func (m *ScanRequestPB) GetCloseScanner() bool {
	if m != nil && m.CloseScanner != nil {
		return *m.CloseScanner
	}
	return false
}

type ScanResponsePB struct {
	// The error, if an error occurred with this request.
	Error *TabletServerErrorPB `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	// When a scanner is created, returns the scanner ID which may be used
	// to pull new rows from the scanner.
	ScannerId []byte `protobuf:"bytes,2,opt,name=scanner_id,json=scannerId" json:"scanner_id,omitempty"`
	// Set to true to indicate that there may be further results to be fetched
	// from this scanner. If the scanner has no more results, then the scanner
	// ID will become invalid and cannot continue to be used.
	//
	// Note that if a scan returns no results, then the initial response from
	// the first RPC may return false in this flag, in which case there will
	// be no scanner ID assigned.
	HasMoreResults *bool `protobuf:"varint,3,opt,name=has_more_results,json=hasMoreResults" json:"has_more_results,omitempty"`
	// The block of returned rows.
	//
	// NOTE: the schema-related fields will not be present in this row block.
	// The schema will match the schema requested by the client when it created
	// the scanner.
	Data *kudu1.RowwiseRowBlockPB `protobuf:"bytes,4,opt,name=data" json:"data,omitempty"`
	// The snapshot timestamp at which the scan was executed. This is only set
	// in the first response (i.e. the response to the request that had
	// 'new_scan_request' set) and only for READ_AT_SNAPSHOT scans.
	SnapTimestamp *uint64 `protobuf:"fixed64,6,opt,name=snap_timestamp,json=snapTimestamp" json:"snap_timestamp,omitempty"`
	// If this is a fault-tolerant scanner, this is set to the encoded primary
	// key of the last row returned in the response.
	LastPrimaryKey   []byte `protobuf:"bytes,7,opt,name=last_primary_key,json=lastPrimaryKey" json:"last_primary_key,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ScanResponsePB) Reset()                    { *m = ScanResponsePB{} }
func (m *ScanResponsePB) String() string            { return proto.CompactTextString(m) }
func (*ScanResponsePB) ProtoMessage()               {}
func (*ScanResponsePB) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ScanResponsePB) GetError() *TabletServerErrorPB {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ScanResponsePB) GetScannerId() []byte {
	if m != nil {
		return m.ScannerId
	}
	return nil
}

func (m *ScanResponsePB) GetHasMoreResults() bool {
	if m != nil && m.HasMoreResults != nil {
		return *m.HasMoreResults
	}
	return false
}

func (m *ScanResponsePB) GetData() *kudu1.RowwiseRowBlockPB {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ScanResponsePB) GetSnapTimestamp() uint64 {
	if m != nil && m.SnapTimestamp != nil {
		return *m.SnapTimestamp
	}
	return 0
}

func (m *ScanResponsePB) GetLastPrimaryKey() []byte {
	if m != nil {
		return m.LastPrimaryKey
	}
	return nil
}

// A scanner keep-alive request.
// Updates the scanner access time, increasing its time-to-live.
type ScannerKeepAliveRequestPB struct {
	ScannerId        []byte `protobuf:"bytes,1,req,name=scanner_id,json=scannerId" json:"scanner_id,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ScannerKeepAliveRequestPB) Reset()                    { *m = ScannerKeepAliveRequestPB{} }
func (m *ScannerKeepAliveRequestPB) String() string            { return proto.CompactTextString(m) }
func (*ScannerKeepAliveRequestPB) ProtoMessage()               {}
func (*ScannerKeepAliveRequestPB) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *ScannerKeepAliveRequestPB) GetScannerId() []byte {
	if m != nil {
		return m.ScannerId
	}
	return nil
}

type ScannerKeepAliveResponsePB struct {
	// The error, if an error occurred with this request.
	Error            *TabletServerErrorPB `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *ScannerKeepAliveResponsePB) Reset()                    { *m = ScannerKeepAliveResponsePB{} }
func (m *ScannerKeepAliveResponsePB) String() string            { return proto.CompactTextString(m) }
func (*ScannerKeepAliveResponsePB) ProtoMessage()               {}
func (*ScannerKeepAliveResponsePB) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ScannerKeepAliveResponsePB) GetError() *TabletServerErrorPB {
	if m != nil {
		return m.Error
	}
	return nil
}

func init() {
	proto.RegisterType((*TabletServerErrorPB)(nil), "kudu.tserver.TabletServerErrorPB")
	proto.RegisterType((*PingRequestPB)(nil), "kudu.tserver.PingRequestPB")
	proto.RegisterType((*PingResponsePB)(nil), "kudu.tserver.PingResponsePB")
	proto.RegisterType((*WriteRequestPB)(nil), "kudu.tserver.WriteRequestPB")
	proto.RegisterType((*WriteResponsePB)(nil), "kudu.tserver.WriteResponsePB")
	proto.RegisterType((*WriteResponsePB_PerRowErrorPB)(nil), "kudu.tserver.WriteResponsePB.PerRowErrorPB")
	proto.RegisterType((*ListTabletsRequestPB)(nil), "kudu.tserver.ListTabletsRequestPB")
	proto.RegisterType((*ListTabletsResponsePB)(nil), "kudu.tserver.ListTabletsResponsePB")
	proto.RegisterType((*ListTabletsResponsePB_StatusAndSchemaPB)(nil), "kudu.tserver.ListTabletsResponsePB.StatusAndSchemaPB")
	proto.RegisterType((*ColumnRangePredicatePB)(nil), "kudu.tserver.ColumnRangePredicatePB")
	proto.RegisterType((*ColumnRangePredicateListPB)(nil), "kudu.tserver.ColumnRangePredicateListPB")
	proto.RegisterType((*NewScanRequestPB)(nil), "kudu.tserver.NewScanRequestPB")
	proto.RegisterType((*ScanRequestPB)(nil), "kudu.tserver.ScanRequestPB")
	proto.RegisterType((*ScanResponsePB)(nil), "kudu.tserver.ScanResponsePB")
	proto.RegisterType((*ScannerKeepAliveRequestPB)(nil), "kudu.tserver.ScannerKeepAliveRequestPB")
	proto.RegisterType((*ScannerKeepAliveResponsePB)(nil), "kudu.tserver.ScannerKeepAliveResponsePB")
	proto.RegisterEnum("kudu.tserver.TabletServerErrorPB_Code", TabletServerErrorPB_Code_name, TabletServerErrorPB_Code_value)
}

var fileDescriptor0 = []byte{
	// 1401 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xa4, 0x56, 0xdd, 0x72, 0xdb, 0xd4,
	0x16, 0x9e, 0xd8, 0x4e, 0x1a, 0xaf, 0xd8, 0xb2, 0xbc, 0x9b, 0xb4, 0x4e, 0x7a, 0xda, 0x9e, 0xe3,
	0x73, 0x4e, 0x29, 0x94, 0x09, 0x43, 0x67, 0x18, 0xa0, 0xc3, 0x05, 0xb2, 0xa3, 0x26, 0x9a, 0x38,
	0x92, 0xbb, 0x65, 0x37, 0x70, 0xb5, 0x47, 0xb1, 0xf7, 0xa4, 0xa2, 0xb2, 0xa4, 0x4a, 0x72, 0xd3,
	0xf0, 0x04, 0x5c, 0x32, 0x3c, 0x01, 0x4f, 0xc0, 0x15, 0x2f, 0xc0, 0x23, 0xf0, 0x14, 0x3c, 0x02,
	0xb7, 0xac, 0xbd, 0xb7, 0xfc, 0xa3, 0xd6, 0x81, 0xce, 0xe4, 0x4a, 0xd6, 0xb7, 0xbe, 0xbd, 0x7e,
	0xbf, 0xbd, 0x64, 0xd8, 0x7b, 0x39, 0x1d, 0x4f, 0x3f, 0xc9, 0x52, 0x9e, 0xbc, 0xe6, 0xc9, 0xec,
	0xb9, 0x1f, 0x27, 0x51, 0x16, 0x91, 0x9a, 0xb0, 0xed, 0xe7, 0xd8, 0x5e, 0x4b, 0x32, 0x47, 0xd1,
	0x64, 0x12, 0x85, 0xf9, 0x43, 0xf1, 0xf6, 0xee, 0x2f, 0x5b, 0x2e, 0xfc, 0x84, 0x33, 0x89, 0x8f,
	0xa2, 0x20, 0x27, 0xa8, 0xa3, 0x99, 0x77, 0x16, 0xf0, 0x2c, 0x7f, 0x28, 0x4b, 0xfb, 0x97, 0x0a,
	0xdc, 0x1c, 0x48, 0xc0, 0x95, 0x51, 0xcc, 0x24, 0x89, 0x92, 0x7e, 0x87, 0x58, 0x50, 0x19, 0x45,
	0x63, 0xde, 0x5a, 0xfb, 0x77, 0xe9, 0xa1, 0xf6, 0xf8, 0xc1, 0xfe, 0x72, 0x26, 0xfb, 0x2b, 0x0e,
	0xec, 0x77, 0x91, 0xfd, 0xa4, 0x3e, 0xb4, 0x8f, 0x6d, 0xe7, 0xd4, 0x66, 0x26, 0xa5, 0x0e, 0xa5,
	0xd2, 0x05, 0xf9, 0x10, 0x36, 0xd2, 0xcc, 0xcb, 0xa6, 0x69, 0xab, 0x84, 0xce, 0xb6, 0x1e, 0x37,
	0x95, 0x33, 0x23, 0x8e, 0x5d, 0x09, 0xf7, 0x3b, 0x34, 0x27, 0xb4, 0x7f, 0x2e, 0x43, 0x45, 0x38,
	0x22, 0x4d, 0x28, 0xba, 0xd2, 0xd7, 0x08, 0x01, 0xcd, 0xb2, 0x9f, 0x1b, 0x3d, 0xeb, 0x80, 0xb9,
	0xdd, 0x23, 0xf3, 0xc4, 0xd0, 0x4b, 0x64, 0x07, 0x9a, 0x33, 0x8c, 0x3a, 0xa7, 0xac, 0xd3, 0x73,
	0xba, 0xc7, 0x7a, 0x99, 0x6c, 0x83, 0x3e, 0x83, 0x4f, 0x86, 0x03, 0x63, 0x60, 0x39, 0xb6, 0x5e,
	0x11, 0xe4, 0x13, 0xcb, 0x3d, 0x31, 0x06, 0x78, 0x7a, 0xee, 0x63, 0x5d, 0x90, 0x07, 0x46, 0xa7,
	0x67, 0x0e, 0x98, 0xed, 0x0c, 0xd8, 0x53, 0x67, 0x68, 0x1f, 0xe8, 0x1b, 0xe4, 0x26, 0x34, 0xdc,
	0xae, 0x61, 0xdb, 0x26, 0x65, 0xe6, 0x37, 0x7d, 0x8b, 0x9a, 0x07, 0xfa, 0x8d, 0xe5, 0x70, 0xc2,
	0xc8, 0xdc, 0xbe, 0xd9, 0xd5, 0x37, 0x97, 0x33, 0xeb, 0x3a, 0xf6, 0x53, 0xeb, 0x50, 0xaf, 0x92,
	0x5d, 0xd8, 0xc9, 0xbd, 0x1a, 0x3d, 0x6a, 0x1a, 0x07, 0xdf, 0xa2, 0x1b, 0xcb, 0x1d, 0xb8, 0x3a,
	0x90, 0xbb, 0xb0, 0x9b, 0x9b, 0x8e, 0x0c, 0x97, 0x19, 0xcc, 0x36, 0x4f, 0x31, 0x4a, 0x9e, 0xcf,
	0x16, 0xb9, 0x05, 0x64, 0x29, 0x1f, 0x3a, 0xb4, 0x6d, 0xcb, 0x3e, 0xd4, 0x6b, 0xcb, 0x45, 0xb9,
	0xb6, 0xd1, 0x77, 0x8f, 0x9c, 0x81, 0x5e, 0x27, 0xff, 0x82, 0x56, 0x21, 0xa5, 0xae, 0xd1, 0xeb,
	0x31, 0xd7, 0x7c, 0xc6, 0xac, 0x03, 0x5d, 0x13, 0x99, 0x09, 0x27, 0x83, 0x23, 0x93, 0xf5, 0x30,
	0x09, 0x93, 0xea, 0x0d, 0x51, 0xc4, 0x29, 0x75, 0xec, 0x43, 0x64, 0xd1, 0xe7, 0x18, 0x78, 0x38,
	0x44, 0xaa, 0x4e, 0x34, 0x80, 0x2e, 0xa6, 0xf3, 0xd4, 0xb0, 0x7a, 0x58, 0x6b, 0x53, 0xa4, 0x31,
	0xcb, 0xdc, 0xb2, 0xfb, 0xd4, 0x39, 0xa4, 0xa6, 0xeb, 0xea, 0xa4, 0xdd, 0x80, 0x7a, 0xdf, 0x0f,
	0xcf, 0x29, 0x7f, 0x35, 0xe5, 0x69, 0xd6, 0xef, 0xb4, 0x75, 0xd0, 0x14, 0x90, 0xc6, 0x51, 0x98,
	0x72, 0x44, 0x7e, 0x2d, 0x81, 0x76, 0x9a, 0xf8, 0x19, 0x9f, 0x93, 0xc8, 0x1d, 0xa8, 0x2a, 0xd9,
	0x31, 0x7f, 0x2c, 0x35, 0x55, 0xa3, 0x9b, 0x0a, 0xb0, 0xc6, 0xe4, 0x01, 0x0a, 0x64, 0xf4, 0x82,
	0x4f, 0x3c, 0x14, 0xc8, 0x1a, 0x0a, 0x44, 0x53, 0x02, 0x71, 0x25, 0x26, 0xd5, 0x21, 0x7f, 0x91,
	0xaf, 0x40, 0x4b, 0xa2, 0x0b, 0x16, 0xc5, 0x3c, 0xf1, 0x32, 0x1f, 0x83, 0xb5, 0xca, 0x92, 0xbf,
	0xa3, 0xf8, 0x34, 0xba, 0x70, 0xe6, 0x26, 0x3c, 0x56, 0x4f, 0x96, 0x01, 0x12, 0xc0, 0x2e, 0x7f,
	0x93, 0xf1, 0x24, 0xf4, 0x02, 0x36, 0x42, 0xc0, 0x4f, 0x33, 0x1e, 0x8e, 0x2e, 0xd9, 0x44, 0xc8,
	0xbc, 0x82, 0x8e, 0xb4, 0xc7, 0x77, 0x95, 0x23, 0x33, 0xa7, 0x75, 0x17, 0xac, 0x13, 0xa1, 0xee,
	0x66, 0xb7, 0x67, 0x99, 0xf6, 0x80, 0x61, 0x37, 0xfa, 0xc6, 0xa1, 0x31, 0x30, 0x0f, 0xe8, 0x6d,
	0xbe, 0x9a, 0x4b, 0x3e, 0x85, 0x6d, 0xbc, 0x60, 0xb1, 0x77, 0xee, 0x65, 0x7c, 0xcc, 0x32, 0x7f,
	0x82, 0x7d, 0xf0, 0x26, 0x71, 0x6b, 0x1d, 0x03, 0x6d, 0xd0, 0x9b, 0x0b, 0xdb, 0x60, 0x66, 0x6a,
	0xff, 0x54, 0x82, 0x46, 0xde, 0xb6, 0x59, 0x2b, 0xc9, 0xe7, 0xb0, 0xce, 0xc5, 0x05, 0xc3, 0x9e,
	0x89, 0x4a, 0xff, 0xf3, 0x8f, 0xf7, 0x90, 0x2a, 0x3e, 0x79, 0x06, 0x1a, 0x96, 0xce, 0x44, 0xbf,
	0x24, 0x20, 0x2e, 0x5f, 0x19, 0x3d, 0x3c, 0x2a, 0x7a, 0x78, 0x2b, 0xde, 0x7e, 0x9f, 0x27, 0xd8,
	0xc6, 0x99, 0xaf, 0x5a, 0xbc, 0x78, 0x4d, 0x51, 0x6a, 0xd5, 0x45, 0x1d, 0x65, 0x59, 0xc7, 0x02,
	0xd8, 0x1b, 0xa2, 0x2e, 0x96, 0x0f, 0x8b, 0x91, 0x8b, 0xe8, 0x7e, 0x38, 0xe6, 0x6f, 0xe4, 0xc8,
	0xd7, 0xe9, 0x26, 0x02, 0x96, 0x78, 0x27, 0x1f, 0xcc, 0xea, 0xba, 0x72, 0x25, 0x28, 0x7b, 0xfb,
	0x16, 0x6c, 0xf7, 0xb0, 0xaf, 0xaa, 0xd2, 0x74, 0xa1, 0xba, 0x3f, 0x4b, 0xb0, 0x53, 0x30, 0x5c,
	0xbf, 0x65, 0x1e, 0x34, 0xd5, 0x1a, 0x62, 0x5e, 0x38, 0x66, 0x73, 0x45, 0x8a, 0xae, 0x7d, 0x56,
	0x74, 0xb2, 0x32, 0xf0, 0xbe, 0x4a, 0xdd, 0x08, 0xc7, 0x73, 0xe1, 0x36, 0xd2, 0x22, 0xb4, 0xf7,
	0xdb, 0x1a, 0x34, 0xdf, 0xa1, 0x91, 0xaf, 0xa1, 0x9e, 0x5f, 0x8e, 0x7c, 0x4f, 0xae, 0xc9, 0xa6,
	0xdc, 0xc9, 0x83, 0xaa, 0x75, 0x9d, 0x27, 0x3e, 0x6b, 0x4f, 0x2d, 0x5b, 0x7a, 0x2f, 0xdc, 0xa0,
	0xd2, 0xdf, 0xdc, 0xa0, 0x0e, 0xe8, 0xb1, 0x97, 0x64, 0xbe, 0xb8, 0x11, 0xb3, 0x0a, 0xd5, 0x1d,
	0xba, 0xad, 0x4e, 0xf4, 0x67, 0xd6, 0x45, 0x0d, 0x71, 0x11, 0x6a, 0xff, 0xb0, 0x06, 0xb7, 0xba,
	0x51, 0x30, 0x9d, 0x84, 0xd4, 0x0b, 0xcf, 0x79, 0x3f, 0xe1, 0x63, 0x7f, 0x84, 0x4a, 0xc6, 0x42,
	0x3e, 0x86, 0x8d, 0x91, 0xb4, 0xe4, 0x15, 0x6c, 0x2b, 0xa7, 0x8a, 0xbd, 0x48, 0x46, 0x71, 0xc8,
	0x7d, 0xd8, 0x0a, 0xa2, 0x0b, 0x14, 0xe9, 0x59, 0x34, 0x0d, 0xc7, 0xf2, 0xee, 0xd7, 0x28, 0x48,
	0xa8, 0x23, 0x10, 0x41, 0x98, 0xc6, 0xf1, 0x9c, 0x50, 0x56, 0x04, 0x09, 0x49, 0x42, 0x7b, 0x02,
	0x7b, 0xab, 0x32, 0x11, 0xe3, 0xc1, 0x6c, 0x1c, 0xd0, 0x13, 0x81, 0xe3, 0xc7, 0x30, 0x37, 0x88,
	0xce, 0x8a, 0x71, 0xfe, 0xaf, 0x38, 0xce, 0xd5, 0xd5, 0xd0, 0x46, 0x52, 0x40, 0xd2, 0xf6, 0xef,
	0x15, 0xd0, 0x6d, 0x7e, 0xe1, 0x8e, 0xbc, 0xf0, 0x3d, 0x37, 0xdb, 0x36, 0xac, 0x07, 0xfe, 0xc4,
	0xcf, 0x64, 0x71, 0x15, 0xaa, 0x5e, 0x56, 0x26, 0x56, 0xbe, 0x46, 0x62, 0xe4, 0x23, 0xa9, 0xdc,
	0x24, 0x43, 0x87, 0xfe, 0xc4, 0x4b, 0x2e, 0xd9, 0x4b, 0x7e, 0xd9, 0xda, 0x94, 0xed, 0x6a, 0x48,
	0x43, 0x5f, 0xe1, 0xc7, 0xfc, 0x92, 0x3c, 0x04, 0x3d, 0xcd, 0xa2, 0xb8, 0x40, 0xad, 0x4a, 0xaa,
	0x26, 0xf0, 0x25, 0xa6, 0x01, 0x4d, 0x5c, 0x53, 0xdf, 0xf1, 0x91, 0xd8, 0x60, 0x6a, 0x66, 0x29,
	0x2e, 0xca, 0xf2, 0x95, 0x83, 0xd5, 0xe7, 0x74, 0x65, 0x48, 0xc9, 0x17, 0xb8, 0x03, 0xb8, 0x37,
	0x56, 0x3b, 0x76, 0x5d, 0xee, 0xd8, 0x5c, 0x9a, 0x14, 0x61, 0xb9, 0x54, 0xb7, 0xc4, 0x37, 0x86,
	0xf5, 0x70, 0x9b, 0xba, 0x03, 0x5c, 0x10, 0x39, 0x4c, 0xfe, 0x0f, 0x5a, 0x1a, 0x7a, 0xf1, 0xd2,
	0xe6, 0xdc, 0x90, 0x1b, 0xa7, 0x2e, 0xd0, 0xf9, 0xce, 0xbc, 0x72, 0xcd, 0xde, 0xb8, 0x72, 0xcd,
	0xe2, 0xea, 0xa9, 0x8d, 0x3c, 0x4c, 0x99, 0x9d, 0x05, 0xd1, 0xe8, 0x65, 0xda, 0x02, 0xa4, 0x6e,
	0x3e, 0xa9, 0x64, 0xc9, 0x94, 0xd3, 0x2d, 0x69, 0xe9, 0x48, 0x03, 0xf9, 0x12, 0x20, 0x4a, 0xc6,
	0x28, 0x3f, 0x99, 0xfd, 0x96, 0xcc, 0xbe, 0xa1, 0xb2, 0x77, 0x04, 0x2e, 0xd3, 0xaf, 0x0e, 0x6d,
	0x87, 0xe2, 0x87, 0x15, 0xbf, 0x05, 0xd5, 0x68, 0x86, 0x8a, 0x26, 0x07, 0x5e, 0x5a, 0x9c, 0x47,
	0x4d, 0x35, 0x59, 0xe0, 0x8b, 0x26, 0xb7, 0xff, 0x58, 0x83, 0x7a, 0x51, 0x50, 0x77, 0x01, 0x52,
	0x04, 0x42, 0x0c, 0x2c, 0x15, 0x25, 0x4e, 0x55, 0x73, 0x04, 0x25, 0x75, 0x04, 0x7a, 0xc8, 0x2f,
	0x98, 0x00, 0x58, 0xa2, 0x0e, 0xe5, 0x9f, 0xcd, 0x7b, 0x45, 0xf1, 0xbc, 0xad, 0x54, 0xaa, 0x85,
	0x05, 0x84, 0xdc, 0x03, 0x2c, 0x37, 0x08, 0x58, 0xca, 0x5f, 0x89, 0x48, 0xe2, 0x7a, 0xd5, 0x69,
	0x55, 0x40, 0x2e, 0x7f, 0x85, 0x91, 0xb0, 0x88, 0x33, 0x2f, 0x1b, 0xbd, 0x60, 0xa9, 0xff, 0x3d,
	0x76, 0xeb, 0x52, 0xc8, 0xb4, 0x22, 0x49, 0x9a, 0xc4, 0x5d, 0x84, 0x3b, 0x02, 0x25, 0xff, 0x85,
	0xfa, 0x28, 0x88, 0x52, 0xce, 0xf2, 0x34, 0xe5, 0xa8, 0x37, 0x69, 0x4d, 0x82, 0xae, 0xc2, 0xda,
	0x3f, 0xe2, 0xbf, 0x02, 0x15, 0xfe, 0xfa, 0xab, 0xba, 0xd8, 0xa3, 0xd2, 0xdb, 0x3d, 0xc2, 0xcc,
	0x5f, 0x78, 0x29, 0xce, 0x0d, 0xff, 0x09, 0x27, 0x3c, 0x9d, 0x06, 0x99, 0xfa, 0xab, 0xb0, 0x49,
	0x35, 0xc4, 0x4f, 0x10, 0xa6, 0x0a, 0x25, 0x8f, 0xa0, 0x32, 0xf6, 0x32, 0x4f, 0xd6, 0x35, 0x5f,
	0x82, 0xf8, 0x11, 0xbb, 0xf0, 0x53, 0x8e, 0x0f, 0xa9, 0x04, 0x0c, 0x2b, 0x49, 0xef, 0xab, 0xc9,
	0x55, 0xc3, 0xbf, 0xb1, 0x72, 0xf8, 0x4f, 0x60, 0x37, 0xef, 0xce, 0x31, 0xe7, 0xb1, 0x11, 0xf8,
	0xaf, 0xf9, 0xd5, 0x3a, 0x28, 0x15, 0x6a, 0x6c, 0x0f, 0x61, 0xef, 0xdd, 0xb3, 0xd7, 0xee, 0x6c,
	0x67, 0x1b, 0x48, 0x94, 0x9c, 0x4b, 0xfa, 0xf8, 0x6c, 0x76, 0xe0, 0xaf, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x16, 0x0e, 0x69, 0xe8, 0xa5, 0x0c, 0x00, 0x00,
}
